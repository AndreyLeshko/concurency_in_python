# Что такое GIL и как он работает

## GIL | Global Interpreter Lock | Глобальная блокировка интерпретатора

Перед тем как начинать работу с потоками в Python, нужно разобраться с тремя буквами, а буквы эти - GIL.
Мы уже знаем, что потоки могут портить друг другу жизнь, удаляя или изменяя объекты в памяти, с которыми другой поток взаимодействовал перед тем как заснуть.
Получается, нам нужно сделать так, чтобы потоки не засыпали, пока не закончат начатую работу с этим объектом, но есть проблема. 
Программа сама не решает когда потокам засыпать и просыпаться, за это отвечает ядро ОС и получить доступ туда мы не можем, а значит не можем контролировать, когда наш поток заснёт.
Но можно зайти с другой стороны, сделаем так, чтобы другие потоки не просыпались в неправильный момент времени и не ломали объекты с которыми работают другие потоки.
Это и делает GIL, он принудительно держит все потоки кроме текущего спящими (выставляет им режим waiting, будто они ждут окончания блокирующей операции). 
Даёт потоку поработать какое-то время и даёт потоку заснуть только в "правильное" время.

Потоки могут засыпать и просыпаться только между инструкциями Python, но нельзя давать другому потоку проснуться, когда первый находится внутри C-кода самого интерпретатора.

Первое время, потоки в python переключались каждые 100 тиков. Тик это условно говоря, одна инструкция интерпретатора (в документации это четко не прописано, некоторые инструкции занимают 1 тик, некоторые несколько тиков), 
например "a = 1". Но инструкции бывают разными, например "a in range(1_000_000)", что тоже является одним тиком, но выполняется явно дольше предыдущей.
Проблема думаю очевидна, эти 100 тиков могут занять довольно много времени и не дать работать другим потокам.

Тогда в версии Python 3.2 потоки переключаются не по тикам, а по времени. Поток засыпает и ждёт 5 мс, затем просыпается, видит что сейчас время другого потока, выставляет флаг "хочу GIL" и снова засыпает.
Текущий выполняющийся поток, в конце каждого своего тика проверяет наличие этого флага и если он включен, засыпает сам (и засыпает он в "правильное" время, между инструкциями интерпретатора, а не во время их выполнения). 
Затем GIL разрешает одному из ожидающих потоков проснуться.

В результате мы имеем один одновременно выполняющийся поток программы Python, вне зависимости от того, сколько процессоров или ядер имеет ваш компьютер.

* Замечание:
Потоки одного процесса не обязательно должны выполняться лишь на одном ядре процессора. 
Планировщик операционной системы может запланировать выполнение нескольких потоков на разных ядрах.

## Немного о "поднятии" GIL
Получается, у нас многоядерный процессор, а если всегда выполняется максимум 1 поток программы на Python, многопоточный код не даёт никакого преимущества в улучшении производительности нашей программы?
Нет, иначе можно было уже похоронить идею многопоточного питона и разговаривать было бы не о чем.
В Python имеется так называемый механизм "поднятия" GIL.

Смысл следующий: когда Python вызывает функцию из внешней библиотеки (написанной на другом языке программирования) 
или функцию операционной системы (например чтение/запись файла с диска, отправка сетевого запроса и др.), то он отключает механизм GIL.
Когда сторонняя функция вернет управление, Python снова вернет GIL. Это называется "поднять GIL" и "опустить GIL".

Таким образом, GIL ограничивает лишь те потоки, где непосредственно интерпретатор исполняет байт-код программы.


## Физические и логические ошибки многопоточности

В многопоточном коде разделяют 2 типа ошибок: физические и логические. 
Физические - это те ошибки, при которых программа просто не может продолжить работу.
Например, один поток начал работу с объектом, ОС его усыпила, второй поток проснулся, удалил этот объект, теперь когда первый поток проснется, не совсем понятно что ему делать.
Это как если бы вы шли по дороге, моргнули, а дороги уже нет и вы висите в воздухе.
От таких проблем в Python нас и защищает GIL.

Но есть второй тип проблем - логические.

1. Race Condition
2. Thread Starvation (?)
3. Deadlock
4. Livelock


# threading

Начнём знакомиться с потоками в python.
Разберем для начала простенький пример:

```commandline
    import threading
    
    def thread_func(thread_num):
        print(f'Hello from thread {thread_num}')
    
    if __name__ == '__main__':
        t1 = threading.Thread(target=thread_func, args=(1,), daemon=False)
        t2 = threading.Thread(target=thread_func, args=(2,), daemon=False)
        t1.start()
        t2.start()
```

Что мы здесь видим?

Мы можем выполнить функцию в отдельном потоке. Создаём объект Thread, передаем саму функцию (функцию! Не надо здесь её вызывать, иначе функция сразу выполнится в текущем потоке, а передадите вы результат её выполнения).
Далее передаём аргументы в кортеже (даже если аргумент всего один, передать его нужно в кортеже).
А что за аргумент daemon? Об этом чуть ниже.

Мы создали поток... но не совсем. Мы создали объект Thread, а это лишь внутренний объект python.
Операционная система о новом потоке ещё ничего не знает. Далее мы вызываем у объекта метод start, поток создается и начинает исполняться.


Теперь о демонах... Аргумент daemon=False указывает, что дочерний поток не выступает демон (фоновым) процессом.
Если вкратце, у нас есть главный поток и 2 дочерних. Если задачи главного потока выполнятся быстрее, чем завершатся дочерние потоки, программа будет ждать завершение дочерних not-daemon потоков.
Если какой-то из потоков запущен как демон, завершение главного потока приведет к принудительному завершению демон потока.
Чтобы понять отличие между ними, посмотрите результат двух нижеприведенных скриптов.

```commandline
import threading
import time


def not_daemon():
    for i in range(5):
        print(f'Not daemon thread {i}')
        time.sleep(1)
    print('Finish not-daemon thread')

t = threading.Thread(target=not_daemon, args=(), daemon=False)
t.start()

time.sleep(3)

print('Finish main thread')


# Not daemon thread 0
# Not daemon thread 1
# Not daemon thread 2
# Finish main thread
# Not daemon thread 3
# Not daemon thread 4
# Finish not-daemon thread
```

```commandline
import threading
import time

def daemon():
    for i in range(5):
        print(f'Daemon thread {i}')
        time.sleep(1)
    print('Finish daemon thread')

t = threading.Thread(target=daemon, args=(), daemon=True)
t.start()

time.sleep(3)

print('Finish main thread')


# Not daemon thread 0
# Not daemon thread 1
# Not daemon thread 2
# Finish main thread
```

В первом варианте главный поток завершил работу, дождался выполнения дочернего потока и затем программа завершилась.
Во втором варианте, после завершения выполнения главного потока завершается вся программа, дочерний поток завершается принудительно.

Дождаться выполнения not-daemon потока можно вызвав у него метод t.join(). 
По сути, not-daemon поток эквивалентен daemon потоку + join(), однако основное назначение join-а в другом, 
он указывает конкретное место в программе где мы должны дождаться завершения дочернего потока. 
Например, мы можем запустить параллельно несколько потоков с разными задачами, затем вызвав join у каждого потока, дождаться их завершения, получить результаты и проделать с ними какую-то работу уже в главном потоке.

Демон потоки следует использовать для фоновых, некритичных задач. Они не хранят важные данные и должны быть устойчивы к произвольному завершению работы.

