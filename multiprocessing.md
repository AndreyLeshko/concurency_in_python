# multiprocessing

Начнём знакомиться с мультипроцессностью (Не мультипроцессорность! Не путайте понятия.).
Разберем для начала простенький пример:

```commandline
    from multiprocessing import Process
    
    def process_func(process_num):
        print(f'Hello from process {process_num}')
    
    if __name__ == '__main__':
        p1 = Process(target=process_func, args=(1,), daemon=True)
        p2 = Process(target=process_func, args=(2,), daemon=True)
        p1.start()
        p2.start()
        p1.join()
        p2.join()
```

Что мы здесь видим? 

Мы можем выполнить функцию в отдельном процессе. Создаём объект Process, передаем саму функцию (функцию! Не надо здесь её вызывать, иначе вы передадите результат её выполнения).
Далее передаём аргументы в кортеже (даже если аргумент всего один, передать его нужно в кортеже).
А что за аргумент daemon? daemon=True указывает, что процесс запускается как демон. 
Если вкратце, это значит что дочерний процесс может жить, пока жив родительский. 
Если по какой-то причине наш основной процесс завершит работу (успешно / из-за ошибки / принудительный kill, не важно), дочерний процесс также завершится.

Мы создали процесс, но не совсем. Мы создали объект Process, а это лишь внутренний объект python.
Система о новом процессе ещё ничего не знает. Далее мы вызываем у объекта метод start, процесс создается и начинает исполняться.

Мы запустили 2 дочерних процесса, они выполняют один принт в консоль и завершаются, но что если там будет сложная логика, которая займет больше времени, чем логика в главном процессе.
Главный процесс выполнил все свои задачи, завершился. Но наши процессы - демоны, они не работают без родительского процесса.
В результате их выполнение прекратится принудительно. Метод join() приостанавливает главный процесс, пока дочерний не закончит свою работу.
Подождали окончание первого дочернего процесса, подождали окончание второго и теперь спокойно можем завершить главный процесс.